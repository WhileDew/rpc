**下面是一个RPC框架应该具有的基本功能：**

![rpc-architure-detail](D:\Study\Projects\guide-rpc-framework-master\images\rpc-architure-detail.png)

1. **注册中心** ：注册中心首先是要有的，推荐使用 Zookeeper。注册中心负责服务地址的注册与查找，相当于目录服务。服务端启动的时候将服务名称及其对应的地址(ip+port)注册到注册中心，服务消费端根据服务名称找到对应的服务地址。有了服务地址之后，服务消费端就可以通过网络请求服务端了。
2. **网络传输** ：既然要调用远程的方法就要发请求，请求中至少要包含你调用的类名、方法名以及相关参数吧！推荐基于 NIO 的 Netty 框架。
3. **序列化** ：既然涉及到网络传输就一定涉及到序列化，你不可能直接使用 JDK 自带的序列化吧！JDK 自带的序列化效率低并且有安全漏洞。 所以，你还要考虑使用哪种序列化协议，比较常用的有 hession2、kyro、protostuff。
4. **动态代理** ： 另外，动态代理也是需要的。因为 RPC 的主要目的就是让我们调用远程方法像调用本地方法一样简单，使用动态代理可以屏蔽远程方法调用的细节比如网络传输。也就是说当你调用远程方法的时候，实际会通过代理对象来传输网络请求，不然的话，怎么可能直接就调用到远程方法呢？
5. **负载均衡**（待完成） ：负载均衡也是需要的。为啥？举个例子我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。



**实现：**

1、首先实现消息传输协议，RpcRequest、RpcResponse，客户端使用动态代理（实现InnovationHandler，调用invoke方法），服务端添加监听端口。

2、使用ConcurrentHashMap存储接口对应的实现类，Set存储已注册服务，通过map获取已注册服务，通过RpcClientProxy动态代理实现方法调用。

3、使用netty对nio进行替换。DefaultServiceRegistry负责服务注册，NettyServer负责服务端，NettyClient负责客户端。

4、实现Kryo序列化并作为默认序列化

5、实现负载均衡：RR轮询、ConsistencyHashLoadBalance（暂定）

6、实现注解（RPCService、RPCEnableDiscovery）

**消息传输协议**

```ruby
+---------------+---------------+-----------------+-------------+
|  Magic Number |  Package Type | Serializer Type | Data Length |
|    4 bytes    |    4 bytes    |     4 bytes     |   4 bytes   |
+---------------+---------------+-----------------+-------------+
|                          Data Bytes                           |
|                   Length: ${Data Length}                      |
+---------------------------------------------------------------+
```

**三种序列化方式对比**

|            | 优点                   | 缺点                   |
| ---------- | ---------------------- | ---------------------- |
| Kryo       | 速度快，序列化后体积小 | 跨语言支持较复杂       |
| Hessian    | 默认支持跨语言         | 较慢                   |
| Protostuff | 速度快                 | 基于protobuf需静态编译 |

### 其他比较

1. Hessian使用固定长度存储int和long，而Kryo使用变长的int和long保证这种基本数据类型序列化后尽量小，实际应用中，很大的数据不会经常出现。
2. Kryo进行序列化的时候，需要传入完整类名或者利用 `register() `提前将类注册到Kryo上，其类与一个int型的ID相关联，**序列中只存放这个ID**，因此序列体积就更小，而Hessian则是将所有类字段信息都放入序列化字节数组中，**直接利用字节数组进行反序列化**，不需要其他参与，因为存的东西多处理速度就会慢点
3. Kryo使用**不需要实现Serializable接口**，Hessian则需实现Serializable接口
4. **Kryo数据类的字段增、减，序列化和反序列化时无法兼容**，而**Hessian则兼容**，Protostuff是**只能在末尾添加新字段才兼容**
5. **Kryo和Hessian使用涉及到的数据类中必须拥有无参构造函数**
6. Hessian会把复杂对象的所有属性存储在一个Map中进行序列化。所以在父类、子类存在同名成员变量的情况下，Hessian序列化时，先序列化子类，然后序列化父类，因此反序列化结果会导致子类同名成员变量被父类的值覆盖
7. **Kryo不是线程安全的**，要通过ThreadLocal或者创建Kryo线程池来保证线程安全，而**Protostuff则是线程安全的**
8. Protostuff和Kryo序列化的格式有相似之处，都是利用一个标记来记录字段类型，因此序列化出来体积都比较小

总的来说，Kryo适用于性能要求很高的场合，Hessian适用于简单易用的场合，而Protostuff则适用于较小的序列化数据大小和更高的兼容性的场合。





**遇到的问题**

1. 使用netty的handler的时候，由于decoder解包错误，导致后续的处理有问题，误以为是后面的一个handler没生效（解决）
2. 使用nacos作为注册中心，但是服务挂了之后不会自动注销（解决）